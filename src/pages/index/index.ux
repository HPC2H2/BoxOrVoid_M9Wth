<template>
  <div class="container">
    <text class="title">箱即是空</text>

    <!-- 游戏信息 -->
    <div class="info">
      <text class="infoText">
        控制:
        <text
          class="playerBadge"
          style="color: {{ currentPlayer === 6 ? '#333333' : '#FFFFFF' }};  
                     background-color: {{ currentPlayer === 6 ? '#FFFFFF' : '#333333' }};"
        >
          {{ currentPlayer === 6 ? "白" : "黑" }}
        </text>
      </text>
      <text class="hint">白走黑，黑走白</text>
    </div>

    <!-- 画布 -->
    <div class="gameArea">
      <div class="row" for="(y, indexY) in [0, 1, 2, 3, 4, 5]">
        <div class="cell" style="background-color: {{ getCellBg(y, x) }}; 
                    border-color: {{ getCellBorder(y, x) }}"
          for="(x, indexX) in [0, 1, 2, 3]">
          <text class="icon" style="color: {{ getIconColor(y, x) }};">
            {{ getIcon(y, x) }}
          </text>
        </div>
      </div>
    </div>

    <!-- 角色状态 -->
    <div class="playerStatus">
      <div class="playerBox whiteBox">
        <text class="playerPos">白: ({{ whiteX }}, {{ whiteY }})</text>
        <text class="boxCount">箱: {{ whiteBoxes.length }} / {{ whiteTargets.length }}</text>
      </div>
      <div class="playerBox blackBox">
        <text class="playerPos">黑: ({{ blackX }}, {{ blackY }})</text>
        <text class="boxCount">箱: {{ blackBoxes.length }} / {{ blackTargets.length }}</text>
      </div>
    </div>

    <!-- 控制区域 -->
    <div class="controlArea">
      <!-- 重置按钮 -->
      <div class="btnReset" style="background-color: {{ resetBtnColor }}" onclick="onReset">
        <text class="btnText">重置</text>
      </div>
      <!-- 切换角色按钮（input不支持background-color，改为div） -->
      <div class="switchArea">
        <div class="btnSwitch" id="switchBtn" style="background-color: {{ switchBtnColor }}" onclick="onSwitch">
          <text id="switchBtnText" class="btnText">{{ currentPlayer === 6 ? "切换到黑" : "切换到白" }}</text>
        </div>
      </div>

      <!-- 方向键（input不支持background-color，改为div） -->
      <div class="controlPanel">
        <div class="btnRow1">
          <div class="btnArrow" style="background-color: {{ upBtnColor }}" onclick="onUp">
            <text class="btnText">↑</text>
          </div>
        </div>
        <div class="btnRow2">
          <div class="btnArrow" style="background-color: {{ leftBtnColor }}" onclick="onLeft">
            <text class="btnText">←</text>
          </div>
          <div class="btnArrow" style="background-color: {{ downBtnColor }}" onclick="onDown">
            <text class="btnText">↓</text>
          </div>
          <div class="btnArrow" style="background-color: {{ rightBtnColor }}" onclick="onRight">
            <text class="btnText">→</text>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
// 导入 prompt 模块
const prompt = require("@system.prompt")

export default {
  private: {
      // 疑似二维数组不触发UI更新，换一维键值对
      // 地图规则: 0=白地, 1=黑墙
      mapRules: {
      // key: "y,x", value: 0/1
      },
      whiteX: 0,
      whiteY: 1,
      blackX: 2,
      blackY: 3,
      currentPlayer: 7, // 黑
      moveCount: 0,
      // 按钮颜色
      switchBtnColor: "#FF416C",
      upBtnColor: "#36D1DC",
      downBtnColor: "#36D1DC",
      leftBtnColor: "#36D1DC",
      rightBtnColor: "#36D1DC",

      // 箱子数据
      whiteBoxes: [],
      blackBoxes: [],
      // 目标点
      whiteTargets: [],
      blackTargets: [],
  },

  onInit() {
    this.initLevel()
  },
  
  initLevel() {
    this.initMapRules()
    this.initBoxes()
    this.initTargets()
  },
  initBoxes() {
    // 白箱子只能在黑墙或黑角色上移动
    this.whiteBoxes = [
      {x: 1, y: 2},
      {x: 2, y: 1}
    ]
    // 黑箱子只能在白地或白角色上移动
    this.blackBoxes = [
      {x: 1, y: 4}
    ]
  },
  
  initTargets() {
    // 白箱子目标点
    this.whiteTargets = [
      {x: 1, y: 5},
      {x: 2, y: 5}
    ]
    // 黑箱子目标点
    this.blackTargets = [
      {x: 2, y: 3}
    ]
  },

  initMapRules() {
    const width = 4,
      height = 6
    this.mapRules = {}

    // 1. 所有位置默认白地（0）
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        this.mapRules[y + "," + x] = 0
      }
    }

    // 2. 四周黑墙(1)
    for (let x = 0; x < width; x++) {
      this.mapRules[0 + "," + x] = 1 //顶部
      this.mapRules[height - 1 + "," + x] = 1 //底部
    }

    for (let y = 0; y < height; y++) {
      this.mapRules[y + "," + 0] = 1 //左边
      this.mapRules[y + "," + (width - 1)] = 1 //右边
    }

    // 3. 内部黑墙
    this.mapRules["1,2"] = 1
    this.mapRules["2,2"] = 1

    // 4. 初始化角色位置
    this.whiteX = 0
    this.whiteY = 1
    this.blackX = 2
    this.blackY = 3
  },

  getMapValue(y, x) {
    return this.mapRules[y + "," + x] || 0
  },

  getCellBg(y, x) {
    // 检查是否是目标点
    const isWhiteTarget = this.whiteTargets.some(t => t.x === x && t.y === y)
    const isBlackTarget = this.blackTargets.some(t => t.x === x && t.y === y)
    const hasWhiteBox = this.whiteBoxes.some(b => b.x === x && b.y === y)
    const hasBlackBox = this.blackBoxes.some(b => b.x === x && b.y === y)
    
    // 优先级: 角色 > 箱子 > 目标点 > 地图
    if (y === this.whiteY && x === this.whiteX) return "#ECF0F1"
    if (y === this.blackY && x === this.blackX) return "#34495E"
    if (hasWhiteBox) return "#BBBBBB"
    if (hasBlackBox) return "#222222"
    if (isWhiteTarget) return "#FFE4E1"
    if (isBlackTarget) return "#E6E6FA"
    
    return this.getMapValue(y, x) === 0 ? "#F8F8F8" : "#555555"
  },

  getCellBorder(y, x) {
    // 角色位置
    if (y === this.whiteY && x === this.whiteX) return "#3498DB"
    if (y === this.blackY && x === this.blackX) return "#E74C3C"

    // 普通地图
    return "#CCCCCC"
  },

  // 重置关卡
  onReset() {
    this.resetBtnColor = "#8E44AD"
    setTimeout(() => { this.resetBtnColor = "#9B59B6" }, 100)
    this.initLevel()
  },

  // 切换角色
  onSwitch() {
    this.currentPlayer = this.currentPlayer === 6 ? 7 : 6
    this.switchBtnColor = "#E03A5F"
    setTimeout(() => {
      this.switchBtnColor = "#FF416C"
    }, 100)
  },

  onUp() {
    this.move(0, -1)
    this.btnFlash("up")
  },
  onDown() {
    this.move(0, 1)
    this.btnFlash("down")
  },
  onLeft() {
    this.move(-1, 0)
    this.btnFlash("left")
  },
  onRight() {
    this.move(1, 0)
    this.btnFlash("right")
  },

  btnFlash(type) {
    this[`${type}BtnColor`] = "#2EB8C2"
    setTimeout(() => (this[`${type}BtnColor`] = "#36D1DC"), 100)
  },

  move(dx, dy) { 
        const isWhite = this.currentPlayer === 6 
        let [x, y] = isWhite? [this.whiteX, this.whiteY] : [this.blackX, this.blackY] 
        const [nx, ny] = [x + dx, y + dy] 
        const width = 4, height = 6 
        
        // 边界检查 
        if (nx < 0 || nx >= width || ny < 0 || ny >= height) { 
            prompt.showToast({ message: "不能越界！", duration: 800 }) 
            return 
        } 

        const targetValue = this.getMapValue(ny, nx) 
        
        // 确定另一角色的位置
        const otherX = isWhite? this.blackX : this.whiteX;
        const otherY = isWhite? this.blackY : this.whiteY;
        
        // 检查是否是另一角色 (允许互相踩踏，忽略地形限制)
        const isTargetOppositePlayer = (nx === otherX && ny === otherY);
        if (isTargetOppositePlayer) {
            // 允许踩踏，直接跳过所有地形和箱子检查，直接更新位置
            if (isWhite) {
                this.whiteX = nx
                this.whiteY = ny
            } else {
                this.blackX = nx
                this.blackY = ny
            }
            this.checkWinCondition()
            return
        }


        // 检查是否是箱子 
        const whiteBoxIndex = this.whiteBoxes.findIndex(b => b.x === nx && b.y === ny) 
        const blackBoxIndex = this.blackBoxes.findIndex(b => b.x === nx && b.y === ny) 

        if (whiteBoxIndex !== -1 || blackBoxIndex !== -1) { 
            // --- 目标位置是箱子 --- 
            const boxColor = whiteBoxIndex !== -1? 'white' : 'black' 
            const isMyBox = (isWhite && boxColor === 'white') || (!isWhite && boxColor === 'black') 

            if (isMyBox) {
                // PUSHING OWN BOX LOGIC (推动自己颜色的箱子)

                const boxIndex = whiteBoxIndex !== -1? whiteBoxIndex : blackBoxIndex 
                const boxes = boxColor === 'white'? this.whiteBoxes : this.blackBoxes 

                // 计算箱子的下一个位置 
                const boxNextX = nx + dx 
                const boxNextY = ny + dy 

                // 1. 箱子目标位置检查：边界
                if (boxNextX < 0 || boxNextX >= width || boxNextY < 0 || boxNextY >= height) { 
                    prompt.showToast({ message: "箱子不能越界！", duration: 800 }) 
                    return 
                } 

                // 检查箱子目标位置是否被另一个箱子占用
                const occupiedByBox = 
                    this.whiteBoxes.some((b, i) => i !== whiteBoxIndex && b.x === boxNextX && b.y === boxNextY) | 
                    this.blackBoxes.some((b, i) => i !== blackBoxIndex && b.x === boxNextX && b.y === boxNextY)

                // 检查箱子目标位置是否被角色占用 (如果不是踩踏，理论上角色不该在箱子下一格)
                const occupiedByPlayer = (boxNextX === this.whiteX && boxNextY === this.whiteY) || (boxNextX === this.blackX && boxNextY === this.blackY)

                if (occupiedByBox || occupiedByPlayer) { 
                    prompt.showToast({ message: "箱子前方被阻挡！", duration: 800 }) 
                    return 
                } 

                // 2. 箱子地形限制检查
                const boxNextValue = this.getMapValue(boxNextY, boxNextX) 
                
                // 白箱子只能在黑墙(1)上移动 
                if (boxColor === 'white' && boxNextValue !== 1) { 
                    prompt.showToast({ message: "白箱子只能在黑墙上移动！", duration: 1000 }) 
                    return 
                } 
                // 黑箱子只能在白地(0)上移动 
                if (boxColor === 'black' && boxNextValue !== 0) { 
                    prompt.showToast({ message: "黑箱子只能在白地上移动！", duration: 1000 }) 
                    return 
                } 

                // 推动成功
                boxes[boxIndex].x = boxNextX 
                boxes[boxIndex].y = boxNextY 

                // 更新角色坐标
                if (isWhite) {
                    this.whiteX = nx
                    this.whiteY = ny
                } else {
                    this.blackX = nx
                    this.blackY = ny
                }

            } else {
                // WALKING ONTO OPPOSITE BOX LOGIC (走上相反颜色的箱子)
                // 允许移动，直接更新角色位置，不推动箱子
                 if (isWhite) {
                    this.whiteX = nx
                    this.whiteY = ny
                } else {
                    this.blackX = nx
                    this.blackY = ny
                }
            }
        } else { 
            // --- 目标位置是空地形 --- 
            
            // 正常地形检查 (如果不是踩踏或推箱子，则需要检查地形颜色)
            if (isWhite && targetValue !== 1) { 
                prompt.showToast({ message: "白角色只能走黑墙！", duration: 1000 }) 
                return 
            } 
            if (!isWhite && targetValue !== 0) { 
                prompt.showToast({ message: "黑角色只能走白地！", duration: 1000 }) 
                return 
            } 
            
            // 地形检查通过，更新角色坐标
            if (isWhite) {
                this.whiteX = nx
                this.whiteY = ny
            } else {
                this.blackX = nx
                this.blackY = ny
            }
        }

        this.checkWinCondition()
    }, 


  getIconColor(y, x) {
    return "#FFFFFF"
  },

  getIcon(y, x) {
    // 角色图标
    if (y === this.whiteY && x === this.whiteX) return "●"
    if (y === this.blackY && x === this.blackX) return "●"
    
    // 箱子图标
    const hasWhiteBox = this.whiteBoxes.some(b => b.x === x && b.y === y)
    const hasBlackBox = this.blackBoxes.some(b => b.x === x && b.y === y)
        if (hasWhiteBox | hasBlackBox) return "■"

    
    return ""
  },

  checkWinCondition() {
    // 检查所有白箱子是否在白目标点上
    const whiteWin = this.whiteBoxes.every(box => 
      this.whiteTargets.some(target => target.x === box.x && target.y === box.y)
    )
    
    // 检查所有黑箱子是否在黑目标点上
    const blackWin = this.blackBoxes.every(box => 
      this.blackTargets.some(target => target.x === box.x && target.y === box.y)
    )
    
    // 所有箱子都到位
    if (whiteWin && blackWin && (this.whiteBoxes.length > 0 || this.blackBoxes.length > 0)) {
      prompt.showDialog({
        title: "恭喜通关！",
        message: "你成功将所有箱子推到目标点！",
        buttons: [
          { text: "继续", color: "#667eea" },
          { text: "重玩", color: "#FF416C" }
        ],
        success: (data) => {
          if (data.index === 1) {
            this.initLevel()
          }
        }
      })
    }
  }
}
</script>

<style scoped>
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 8px;
  background-color: #667eea;
  height: 100%;
  width: 100%;
}

.title {
  font-size: 18px;
  font-weight: bold;
  color: white;
  margin: 6px 0;
}

.info {
  background-color: #ffffff;
  padding: 5px 10px;
  border-radius: 6px;
  margin: 6px 0;
  width: 95%;
}

.infoText {
  font-size: 13px;
  color: #333333;
  font-weight: bold;
  text-align: center;
}

.playerBadge {
  padding: 2px 5px;
  border-radius: 3px;
  margin: 0 3px;
}

.hint {
  font-size: 10px;
  color: #666666;
  margin-top: 3px;
  text-align: center;
}

.gameArea {
  display: flex;
  flex-direction: column;
  background-color: #555555;
  padding: 2px;
  margin: 8px 0;
  border-radius: 4px;
}

.row {
  display: flex;
}

.cell {
  width: 34px;
  height: 34px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid;
}

.icon {
  font-size: 16px;
  font-weight: bold;
}

.playerStatus {
  display: flex;
  justify-content: space-around;
  width: 95%;
  margin: 8px 0;
}

.playerBox {
  flex: 1;
  margin: 0 3px;
  padding: 5px;
  border-radius: 5px;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.whiteBox {
  background-color: #f0f0f0;
  color: #333333;
}

.blackBox {
  background-color: #333333;
  color: #ffffff;
}

.playerPos {
  font-size: 12px;
  font-weight: bold;
}

.switchArea {
  margin-bottom: 10px;
}

.btnRow1,
.btnRow2 {
  display: flex;
  justify-content: center;
}

/* 控制区域 */
.controlArea {
  width: 100%;
  margin-top: 8px;
}

/* 切换按钮 */
.btnSwitch {
  width: 45px; /* 适配手表屏幕 */
  height: 60px;
  border: none;
  border-radius: 4px;
  display: flex; 
  align-items: center;
  justify-content: center;
  background-color: #ff416c;
  padding: 4px;
  margin: 8px;
  flex-wrap: wrap;
  text-align: center;
}

/* 方向键容器：调整为居中布局 */
.controlPanel {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 8px;
}

/* 方向按钮：增加flex布局，确保文字居中 */
.btnArrow {
  width: 30px; /* 增大按钮尺寸，适配手表触摸 */
  height: 30px;
  border: none;
  border-radius: 2px;
  margin: 1px;
  display: flex; /* 关键：让文字居中 */
  align-items: center;
  justify-content: center;
}

/* 按钮文字：明确设置字体大小，确保显示 */
.btnText {
  color: #ffffff;
  font-size: 15px; /* 增大文字尺寸 */
  font-weight: bold;
  text-align: center;
}

.boxCount { 
  font-size: 10px;
  margin-top: 2px;
}
</style>
